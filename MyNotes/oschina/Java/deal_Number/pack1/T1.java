package oschina.Java.deal_Number.pack1;

/**
 * \* Created with IntelliJ IDEA.
 * \* User: LinZiYu
 * \* Date: 2020/5/2
 * \* Time: 11:45
 * \* Description:
 * \
 */
public class T1 {

/*
我们先来看看十进制小数转二进制小数的方法

对小数点以后的数乘以2，会得到一个结果，取结果的整数部分（不是1就是0），然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小数部分为0或者位数已经够了。顺序取每次运算得到的整数部分，即为转换后的小数部分。

演示：
0.125 ×2=0.25 .......................0
0.25×2=0.5.............................0
0.5×2=1.0................................1
即 0.125的二进制表示为小数部分为0.001
其实我们可以看出，这种方法实质上就是用1/2,1/4,8/1...来组合加出我们要转换的数据值，但显然不是所有的数都能够组合出来的。如0.1。

 0.1×2=0.2 .....................0

 0.2×2=0.4 ......................0

 0.4×2=0.8 .....................0

 0.8×2=1.6.......................1

 0.6×2=1.2.......................1

 0.2×2=0.4.......................0
 .....
从上述计算过程我们可以看出，这是个无限小数，所以在这种情况下我们的float、double只能舍去一些位。

那为什么我们在直接给float赋值在输出时没有看到精度损失而在运算时却会出现呢？

确实是这样，如下

float a = 0.2f;
System.out.println(a);
//输出0.2
对于上述情况我只是查了资料，好像是因为编译器会进行优化，当我们存储的数据特别接近的时候，编译器会很贴心的返回我们想看到的数值（即二进制浮点数并不能准确的表示0.1这个十进制小数，它使用了0.100000001490116119384765625来代替0.1。），至于到了运算中，就会出现精度损失较大从而看到了真相。如果这块说的不对欢迎小伙伴们在评论区指正！


 */


/*

BigDecimal 原理
我们一般会使用
BigDecimal 来避免出现精度丢失问题，至于为什么BigDecimal 可以避免，而float或double不行，我们在此不详细讨论，简单来说就是BigDecimal 通过借助整数来表示小数的方式，因为对于整数而言，二进制和十进制是完全一一对应的，用整数来表示小数，再记录下小数的位数，就可以完美的解决该问题。

BigDecimal 用法
java.math.BinInteger 类和 java.math.BigDecimal 类都是Java提供的用于高精度计算的类.其中 BigInteger 类是针对大整数的处理类,而 BigDecimal 类则是针对大小数的处理类.

BigDecimal构造方法
BigDecimal BigDecimal(double d); //不允许使用
BigDecimal BigDecimal(String s); //常用,推荐使用
static BigDecimal valueOf(double d); //常用,推荐使用
double 参数的构造方法,不允许使用!!!!因为它不能精确的得到相应的值;
String 构造方法是完全可预知的: 写入 new BigDecimal("0.1") 将创建一个 BigDecimal,它正好等于预期的0.1; 因此,通常建议优先使用 String 构造方法;
静态方法 valueOf(double val) 内部实现,仍是将 double 类型转为 String 类型; 这通常是将 double(或float)转化为 BigDecimal 的首选方法;


double 参数的构造方法,不允许使用!!!!因为它不能精确的得到相应的值;
String 构造方法是完全可预知的: 写入 new BigDecimal("0.1") 将创建一个 BigDecimal,它正好等于预期的0.1; 因此,通常建议优先使用 String 构造方法;
静态方法 valueOf(double val) 内部实现,仍是将 double 类型转为 String 类型; 这通常是将 double(或float)转化为 BigDecimal 的首选方法;


 */
    public static void main(String[] args) {


    }
}
