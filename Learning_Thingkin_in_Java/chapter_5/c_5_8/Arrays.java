package chapter_5.c_5_8;

/**
 * @Author: Mr.Lin
 * @Description:
 * @Date: Create in 15:07 2019/12/25
 */
public class Arrays {


    public static void main(String[] args) {
        int[] a1 = { 1, 2, 3, 4, 5 };
        int[] a2;
        a2 = a1;
        for(int i = 0; i < a2.length; i++)
            a2[i]++;
        for(int i = 0; i < a1.length; i++)
            prt("a1[" + i + "] = " + a1[i]);
    }
    static void prt(String s) {
        System.out.println(s);
    }


//    大家看到a1 获得了一个初始值，而a2 没有；a2将在以后赋值——这种情况下是赋给另一个数组。
//    这里也出现了一些新东西：所有数组都有一个本质成员（无论它们是对象数组还是基本类型数组），可对其
//    进行查询——但不是改变，从而获知数组内包含了多少个元素。这个成员就是 length。与C和 C++类似，由
//    于Java 数组从元素 0 开始计数，所以能索引的最大元素编号是“length-1”。如超出边界，C 和C++会“默
//    默”地接受，并允许我们胡乱使用自己的内存，这正是许多程序错误的根源。然而，Java 可保留我们这受这
//    一问题的损害，方法是一旦超过边界，就生成一个运行期错误（即一个“违例”，这是第9 章的主题）。当
//    然，由于需要检查每个数组的访问，所以会消耗一定的时间和多余的代码量，而且没有办法把它关闭。这意
//    味着数组访问可能成为程序效率低下的重要原因——如果它们在关键的场合进行。但考虑到因特网访问的安
//    全，以及程序员的编程效率，Java 设计人员还是应该把它看作是值得的。
//    程序编写期间，如果不知道在自己的数组里需要多少元素，那么又该怎么办呢？此时，只需简单地用new在
//    数组里创建元素。在这里，即使准备创建的是一个基本数据类型的数组，new也能正常地工作（new不会创建
//    非数组的基本类型）

}
