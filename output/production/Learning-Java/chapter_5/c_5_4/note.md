

## this关键字


如果有两个同类型的对象，分别叫作a 和b，那么您也许不知道如何为这两个对象同时调用一个 f()方法：

class Banana { void f(int i) { /* ... */ } }
Banana a = new Banana(), b = new Banana();
a.f(1);
b.f(2);

**若只有一个名叫f()的方法，它怎样才能知道自己是为 a 还是为b 调用的呢？**


为了能用简便的、面向对象的语法来书写代码——亦即“将消息发给对象”，编译器为我们完成了一些幕后工作。其中的秘密就是第一个自变量传递给方法f()，而且那个自变量是准备操作的那个对象的句柄。

所以前述的两个方法调用就变成了下面这样的形式：

Banana.f(a,1);
Banana.f(b,2);

这是内部的表达形式，我们并不能这样书写表达式，并试图让编译器接受它。但是，通过它可理解幕后到底发生了什么事情。

假定我们在一个方法的内部，并希望获得当前对象的句柄。由于那个句柄是由编译器“秘密”传递的，所以没有标识符可用。然而，针对这一目的有个专用的关键字：this。

**this 关键字（注意只能在方法内部使用）**


可为已调用了其方法的那个对象生成相应的句柄。可象对待其他任何对象句柄一样对待这个句柄。但要注意，假若准备从自己某个类的另一个方法内部调用一个类方法，就不必使用this。只需简单地调用那个方法


即可。当前的this 句柄会自动应用于其他方法。所以我们能使用下面这样的代码：


class Apricot {
void pick() { /* ... */ }
void pit() { pick(); /* ... */ }
}


**在pit()内部，我们可以说 this.pick()，但事实上无此必要。编译器能帮我们自动完成。this 关键字只能用于那些特殊的类——需明确使用当前对象的句柄。例如，假若您希望将句柄返回给当前对象，那么它经常
在return 语句中使用。**

